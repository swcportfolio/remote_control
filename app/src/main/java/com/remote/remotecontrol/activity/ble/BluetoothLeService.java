/*
 * Copyright (C) 2013 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.remote.remotecontrol.activity.ble;

import android.app.Service;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothGatt;
import android.bluetooth.BluetoothGattCallback;
import android.bluetooth.BluetoothGattCharacteristic;
import android.bluetooth.BluetoothGattDescriptor;
import android.bluetooth.BluetoothGattService;
import android.bluetooth.BluetoothManager;
import android.bluetooth.BluetoothProfile;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.media.AudioFormat;
import android.net.Uri;
import android.os.Binder;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.util.Log;

import androidx.annotation.RequiresApi;

import com.remote.remotecontrol.retrofit.Convert;
import com.remote.remotecontrol.retrofit.ConvertIO;
import com.remote.remotecontrol.retrofit.RetrofitClient;
import com.remote.remotecontrol.retrofit.RetrofitInterface;
import com.remote.remotecontrol.retrofit.STTModel;
import com.remote.remotecontrol.retrofit.SpeechModel;
import com.remote.remotecontrol.retrofit.UeiRcModel;

import org.json.JSONObject;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.stream.Stream;

import javax.xml.transform.stream.StreamSource;

import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;


/**
 * Service for managing connection and data communication with a GATT server hosted on a
 * given Bluetooth LE device.
 */
public class BluetoothLeService extends Service {
    private final static String TAG = BluetoothLeService.class.getSimpleName();

    private BluetoothManager mBluetoothManager;
    private BluetoothAdapter mBluetoothAdapter;
    private String mBluetoothDeviceAddress;
    private BluetoothGatt mBluetoothGatt;
    private int mConnectionState = STATE_DISCONNECTED;

    private static final int STATE_DISCONNECTED = 0;
    private static final int STATE_CONNECTING = 1;
    private static final int STATE_CONNECTED = 2;

    public final static String ACTION_GATT_CONNECTED =
            "com.example.bluetooth.le.ACTION_GATT_CONNECTED";
    public final static String ACTION_GATT_DISCONNECTED =
            "com.example.bluetooth.le.ACTION_GATT_DISCONNECTED";
    public final static String ACTION_GATT_SERVICES_DISCOVERED =
            "com.example.bluetooth.le.ACTION_GATT_SERVICES_DISCOVERED";
    public final static String ACTION_DATA_AVAILABLE =
            "com.example.bluetooth.le.ACTION_DATA_AVAILABLE";
    public final static String EXTRA_DATA =
            "com.example.bluetooth.le.EXTRA_DATA";

    public final static UUID UUID_SERVICE = UUID.fromString(GattAttributes.UUID_SERVICE);
    public final static UUID UUID_TX = UUID.fromString(GattAttributes.UUID_TX);
    public final static UUID UUID_RX = UUID.fromString(GattAttributes.UUID_RX);
    public final static UUID UUID_CTL = UUID.fromString(GattAttributes.UUID_CTL);
    public final static UUID CLIENT_CHARACTERISTIC_CONFIG = UUID.fromString(GattAttributes.CLIENT_CHARACTERISTIC_CONFIG); //Descriptor

    private RetrofitClient client = new RetrofitClient();
    private String URL ="http://106.251.70.71:50010";
    private String sampleDATA = "52494646342A000057415645666D74201400000011000100401F0000D70F0000000104000200F90166616374040000000051000064617461002A000006000000572AAA22E87DA881912891043B09A49F8000D12920080FA2830D9041B06981009D8901872B981490480BA12ABA8A97A92D801D11271A09219390075AEA025899097396AA889A9920C1093A82B01C31D9987082991962BA0009A12C8028AA03733294011590A23A412332068210E9CEA91AFA99A98C98111059300453421414B30924E98A0018111099B0ACEBFA81307706AA8912882103CA09224292AE0B819888FB0B0100CB11EA0181AF20B09C7784AA19000822A1AB10917213A8BB8B281380ECBC29809953E90A01B961A1CB1A712780AA09011011A19A7114A09C891108A8BE09000090B88F849909B4AA09F00C778299889932839A01CA484748032800A989889B4081AD088011019189BBDBAD1F087367A09A28811832A09C202224E9BA108889B8BF1000B01CA11E10F80A02CB7947A89A01802012BA0A11293781BABB883201C8CE9B02983995AE10901B16BAAC117702A89A10001111AA194701CA99188180EA9B00000089FB48989940AB9A81CF70279889982933A819A08C7484B989982083DB89A81A8210C1AD23A930C49DA1B00C778589889930028A01B978059900BB2984AB11FC2912AB12CA40A088119B949F8850478898A819228130F819438189BC0A109921FC9B211003BE29905389BA028E88D168178008B93A010814A9310481B1DC89029908DC8D22A888909E026CB151CB88110B90728702300018819A0988211291538282C8BBA33891D1ADAD0A19F2098EB17899920998D1288A157002110A9A882910351369D8910BB881A9C09809D9001CA2268FA1821AA2828CE408907103321ABA984A9816080399C08ABC812CA0C80D8808863AF8023D98133CE8228CA1312104C10AB8204A88326990138DA1A9213223A48B1BAE12AEA69CE0009EA10CA0191B7131538882A880A804400220880CB90DAAB8081AF140AF01A92189D438E92099400A057001133898810C988138C0C28CDC999CA9080A081988F0010A94328996612BA37A980311823129B61589B5288A298A18D9D590C9D298A0816A09100880408A962019114A0001111010A4132018612B8E020C000110189129A98CCBEBAADB9A8CAA09B8A9EF8ABCAA8C982042343322A8DDDBBCABACA989081800210023344423152433321730823331143115488114010351022003503C11292A00042BD0D438AAA42DA009A100FA83CBB509A881031E02A24900305008A1860EA38C80B189C0AC9B9DA1EA0B9CB01CD9B9018AD90089C028F020890A0C85902BBA860CA12B9DA0409A821B0200C88615208420BA2619245AB060A111A120B0914919D7100A8B881F91C039AA049B19815D12858023903141DA125D8028B329B889B80D3DC0CAC40BA2490D23891920E1131CA32549398100421F0088180008F3496BC9A33A98E0832B99B2D40089C2408A88C2B35C66010C0081050989402A9009019C6CA43A1CC32A09C1080BCBB4530AC8250D00001B29A0A732D02931D00219A70029B2289A631E80A0A1B7299A1BD220B989A4F980C3203EB82A8308E8260AB1A3002FB2820090815CF4008902092BA921F11960990908B3581AB52809B2788AC131A6002A92203EB8162D9809813A09A883ABB5439F90886BAA929418199491303CF0231E98841AC3100AC5309A942AD102AA9101C0490189C273BA02899609120AB5185DC81329F15890012DB2121CA1321FA98338081BF207192128C81444912177372747E99C2081AA2183CB28029A2801884282092980B00808106952E98A32DA0A42D90C4191B861A11B2C84BA1832B016FD30004894AA1893A12B860936C0AC4883BB3285BA7991BA40A38C3210BB8904AA3037BA33B3BD1C80CB32B18A47809A1202FF2811982904B90801CB4B15A8BC43028B318068818B53A69A91CB52B30E82CB3923DC1923CA5B05998913AA1040B82288012105EB21ABCA39A171839A32FC3898EA0980890B87906984AC2884000B01208A27BBA052BA8A59E8883194500033898321DC089BCA49C2BC09125181ED89B9BF28234424818810E89B88A83925113133B8D999FB9C18919A15A00B41BA0A2594190329BC078A90510833321523AC557333C9BDB9AB9C218089328120461100B8AD820998C9CB990E1154020119426482A88A221219B0CF0AB09F1111033500C10923A09DBBEB8911DA0C2053260281889A4032242181A89CFBBBBE09222033FA0AC80918918E08908802B93D77041100A9808800520282BACE9A9AAB0A01202362F81B82A0AF908901130838D93077012110A09AB9BC39353131B09CA0CDAABA208A31CFD3209218199E10FB98138121360A362112039D212358049088F8BEBCBA1B2212A20D103341A338AA82DF018A298370350280801853922080A038FAAEAABB2A88922ABE29140781C08BCB20ACA9A9EDA97216888A42430108888099AA8989A8BDDDAAB989091037221023BD88CD89003804AB99553582CA0B4227129088CABBAB0A9331169198CF8899512880A9AC089D024091822025E0BFF4380019443391BB8832FC9A211189323391DBBD2A3682998800088929342201BABF1B5302AA88A8FCA90980801908AB8909A9948420442271188118A801EB988C0A9B08ADF88088B14B8B9910A500C8B09940023DAAC33922A5A819B17C9610A8B29B2401BB53CB1235AB2090EA730189488C0002B181180D71A30908C88B469899139D3084BA2993FB53289B8388A816828C21CA30A52A0A110F94A209839B2D95A00192DA48A28589820C20A39A73AB0B6382C911B80D41A02BD0C94111F1118AC932950A80C85C01901101BB4C04AB21A88D300398F2C18A0308884AE96A109000B0BB270028409D89259A20B10C2C950800909F03008802D92B213DA969010B00BA2CB3262F92BA7B00A083939E431B89869A0A15892AB3B939030AB1A49F42C31C92F9208020088A8923A69AB58B1C538180B30A6CA49891F809589000308D8A86912CD288281A9801DB935028BA87981891C451A9813994118900E03839C1B418B0D294991BF08298A3318FB409339A72092D11A8200912BD9522C223A8C3A3D98CE09A080A89492D8A215951E831102A970492178796B777B068B980D034908BB31C200E3208748990B92D90419891968981CB099F88BA0A8141800B127047383811080A90CCC123158880E038CC2408CF9A2181BB8080800080000000080010001010100112121294777777088008808989A829AB109B41B550C27E0C410080A941B12480A1B98F98508903089991490528A809CC080A93909DE109BABA2918731730929141DB009E800820E821AC92A84AB344398568A89229BA961BB29A1BCC209CA2811A973AE1420A02209A008AD420EB08981A071C924800135299820B0BB578A1230AF2199B9138D8430BD219CC028D01A25DB159B80010B8171A8429008929CB2099251121D08BD98BA95A811390F22AEB108AB2428D112468A419A209818A218FA0AB9A9901A312B15041AF871CC1809890842DC159A03348A3150AC3389A137880038CB1999CB058D8889B9B1BE23DC33188C8009BC2881A4270340112C9109231172A851A00C90ABC800990A1DFA01A9048B02800FBB3F23400C00A2BD3630817180090599341A9A9108B070DA8AA1BD840A9119812048DB35D92309080A8AB243D258008F918B888980B138830907053273113BAC1BB99FB88CCA981488398138F012934C819926122A8BC9F88AA22AB41A07702A0AABB0192111720109A8E1330218698A89C210A1B8FA32B11B977A9819918D918A28A87480105109BA24BF1302AA280599369B10BC9AA2D901C213A07C988E00028904A009B29AD17A080A824103075908A8C8B11208BC872C2118091305C944901112098019FDC1A9C880BDB1A30811716911091D94190DA1919188E892A121843329013B41D1A3B70003209E2A8BDBDAC8000801223088243207216123386895C223E001800E2ABC9898E2079888099982831153218A21C30149DAE0D09989A910240021101041498DA9C392521F9AF31312822A8C9990B5001BD0B64209891A088C9001198E0E8B1C2A0A0C192842131503810082A0AC1A02188061185B2A3B593E1C2D099B183958308385D188090B49191A2826A0B9049A0811DC8B290F89989C8F2C3A3080891303C1B483C188090024B20083028A1B6033309A97288920396001191023A08880BD484C0019091832D999A451A3A1B13F2531A80595B8981211AA09721AA86183AA1D1119AB0A719D808098A2C0A4E1D8810A890008E801ABBA6A100A928E2A6991800F32018992BA1349F41D39982A3CC00830F28B1206A010C00309AAAB604CA3292BB37839D12928D03922D8A07898912B98A96B2AD25B18B15E2180098BB62B0082113BC20418EA0238A188990E1A0721A0C110AC9B395BB622A1E2800B00197A1A07809986900CA8395C039812B2F10890C84C28821A01D30A08C3218DD152BC91248AB1132AC9913F10B05180F02889920A0C1241B8B022BDC4890920943BA9142128F69A9C2331ADA433BF8311A999812C10085181F20A0493CC2A04098D15909A812A8B398408C873A8B925C1B980080A50A9391614BC19830E9D3208A0030C0238980323F99D40028803BA4A32F81D31922E9301BD3A52A98945C8898011B901019C69191894B88092AA906FA81380CA0872A58010B00282BC2387CA0A0019AB4A23B91698BA2B6A30A94319C62A0913000F318303E99040C3A20B923D0948118950D93A04892929B5C19C60008996B2A9107180587861727178727AF19984000018DA42A82A831371D899950A812008942AF4898839609E2B0A0C1192C7200AA880089BF810093400722CA9C8808922082B2AA9239272500B14A1D0328BA8712901088F82DA18119BD1688890089213BA509B9F36902998F881A921151B102AB23278A819ACD218A159909015B830C1A83798109A8DC0890334009031D92AA08FF188801138B920D004800A04B03841BFA8F1800339C043015F99BA910128268B00980143292318BE933AD860AA0313C862A35213D00CCAA19BB179908122B170B808120F30A98AB49D0509180229B252991104A8618C89A19A11CC9A940026311F9899B823A811429E4090A03499223CFB01AB8903B0175928209A27181233894A9BE919E00310885BB1409A899AC93368A862CB09CEB902836432000A898B0182501BDBCCB89893181399258C28D8028AF629111A0BB9CDC194323269208888819D00985BA1AC82B009073D119A98A19E039033017CC1AA12AA198BF215325338A18108A06980000CD80ABC91899428809890141B5AF13088982DF08923B240829F14A920239F24B323702B98A18D0AFBA9A302531929A8A886881339AF10922048DB84A82B94AB39C99327294ADA95252E0183E000091CBEB89881300118210831CA9BD3AD20280E83B882939574281008EAA999A80712303BCAC18104533D98AA99A89907117B89AB90E12080300A8511080839D4341A19D2004CB0911BCAB710418DB89191312DE1A46811898BA8A1041258011D99D890A229898339B2789AA92AE900A2857A942232281DF9A991844818900BB08BABB51034591DD0A802142018A108940A20C262121B9AE28014292CF1B202154938999DB0C132026E8AF0000981820028A10338A12408400B9E91AB98A9B34571141328288D8CC9ABBAD89313602105292BAACCB09A8207523C8DC9A0021210211810820D92A261380EB8C809A32023004891189DB7182BAECCB09BDF92B0040262399C99D21919CA8AD19474381B9AA9908230111B89C021201FD8B53839AB81A54D0BD88231390BB2A67221290ABAA9A089919E9AB8A9A7214E8BDBA097326809980082181881132349219B1DDACAA8B10912802FB8A90AA40B178348141828931E09BAAAA8A12DB1B91AE21A38C21BD1BA08A53146325801898AC28938090BC1B011033D123023977922925904123105401122130363232241152214135222403FABCCDDCBBCCCBAAAA99103253343232332222022214212201AB9ADABA01810951063222244221340339549138029944848A45B818329A3913BC690AC9FAAEABBCACBBFBAA999BBA99093843532414431324231234810810B529020F0099808809D18884B851CA0C41CAB031D9A2A2290FCB912EDB91B9C8A8B08C98C1090BE1B8111090054020A504206101126288B24012843C23108206211070A0000D0AE240899820B02D851A1BA59149B91021D81850EA2000E00992900F92A139034B98A0093EF20020E8292CC40829D48910099902188BA33058007B419B38B0E81891939F10C20C1303AB3D292AF1B342B8417586989080B0812D99A19A9998AF90011C3292289293122A2E0693A6325008892BB74929D3234C98A1391C908AB5120910293F1B2E8938AAA4B210E0C3300D19B290948C38BA90861CA72969AA211A3AA901203C1CB160006B9AA1B58229E1C3A393C202B993308F8065010C000FA00409100903AA4159C1434E2A99401CA8A3D0C5818198012C3A3CD082A9B291792C182CD381A24A1A833CF2A39096A1118BB78201A8613D190B4A1A8889C7020918590F8080B25A9B9338319020BCF6083B0CC2A303118890222F1D81483A00034A2F89A1924B11E4131980B2A8202AD8C4411CB09619288001081C118AB57F770A008B199B9C9011813388A59AFB900A020052118291BB9BAC80813562821188ABF9993A0934422090E29AA89A1A0406310101BA0DBB0B793022051008ABBA00494404860482B2235376858B08909999D8880C88281AA2C88DC8B1118B98E185218BE0832CC81119A382532C99010EA2480905894080D80129A640011800081319AA3BB5D492382A907B991099A4022AAB97491919DBA5121D91509B939190A381A01F12B9A1923B1C7A8D83C9A886BA23C839D51818B9203A994B330FB8861AA690882A2AA12DD2318E03808A03A80838F820B06A90C351AA00410AC9A21168C09309240DD4301AF3013AA8841B10021E90B39A06191A5B804C89B32AA9A65AB0110CB3B191B708807D8A82A18910104E5C9982B082013C0008C8860829B932DC8519024D9018A0C71090028A93111A1110699D22A0A68B252E199211B007903119D0680AA894181B9BC710A089D3110B2A00308F8308D982210D90019B3B917E89A843EA84A0824B0A08A001A5C003C894B2480A032D085BAA64010E00243B3F88C293A71819105A999359082ADAB2F4001C010C281B0998B195C181905C0A088149F894B130ABA5805BB0836A8089030B183F994099937C89A499938992C1946EA9A311092A182B933A2EF5010829A9A3040B1992792C18A8B88790D482A118A15C2B9829508CA3B2599880699A8218B2541C28088C00936AE9833AA1A2221FA238C0932AA9051F81411BD2A300100F888198969098A2228A5B895A1B1CF3889091C4284D0A923CA8A41108C8970A9088837BC11103C1240A2DB095100B7A90C181B131AA81B9286B882F900B1E819BB3BAD908E08A191A291E3A38BA181010E5A71000D0313BD02191E3512BB2234C890194C303212E103A1F010B00B750299840AB061909026C1C92003AB0704B881888A37A2C80391CC29281E0A318A921591E29195B2CC08110E2925A0A901898B311C8B47B999308982100298C862929A16C09B4201D92A28108A6212CC2023CE3A4818981500AA1143E0A010AA0E3B232082928196BB9C759890A102910310B99B90FF8A19092C3B393995D9BA19498C5B3220CC1C4B1941CBA132E8A88CA2CAB902EABA41092B53229C73299C403291AA110384C082D18C443199A100BC4260C214A9984090B00B7289969819229D084802809C62228E094A192081B3E999410F320193DAAB1E3A1826B1A92F102881A2B1C0AC380B6822B923CF98229093B49F9A4881998A1D32224011000B6028AA32A3F8839D2B401912B199D855B88B2409890B8C198B8761BE28380C1905A8AB3412A4DB8032C0A71A7100A8018590A9428A0B5398D81815A099149B8020D09D9201B094ABDB22C0CC192D094201F982A0AA9D3A5390A89B30BF00109491A21184CAA93AB85D0059014391B08882C6B918420A5F3853A99936A0A00002088C293203918F601888298042CC1212E80B2218BB3591BB1500980C7309AC61009080839E9A7282A0AA2823A1E922918C0A65C899091113A282F9909B1A481305C2DB095398AB38018391D104EA9836D98A211290A82E0847A0B114B0AA3110C88A3693BD09488808129A17A2BC09209B0E51119208A180C921D90A2010C00B0A7200AB25C1A88A32AA2452AB4869A11E0288BB4894AAB500AE1841A89032F3BC003008160B994281CC1840809C7300CB2208A1290899428AA0BC7788A91819A080028B2852DB0825A1BF0823A09926CBB872A0BA2010818C98539001BA307C8228B19940A3280B914F5198BA2C031DA612C92108B022B101F80219E814B88A928A902BE000C931E4AB4C9120D10C938AB2A918730AA489FD30992A0119700223A01FBA4393A0B10130343B3A3E681389B14938049902AC35BC1110D99CB20C8A92CD0A000F3C910A9B013DA9160A9B0101F0980B8815B28A64980B83EAA053AC01518A901309F037188C9211AC4101B90347081A989BCD03822147A010D001120F0AC0A900A5511888199AC81BDA90524A49038ABEA2B11E3380BB5204BA5993B94A01D13931F8191399BA438289D937A03280882BBBFD8502190881302F18B39A0A03713088BF2A9AD082042A40129A8E00D19901B0A070000A022ABE94999C10820D589A20A93986AAA9340A192302BCDB99CA57B031089109C991005932D90520B894521054B208CC318CA060A1C10D9801AC2910D90A129CAB1729B98229A87090201C921D351A90222004E001039E08639C0210919F3411AB3132BA8831AA113959504A27A0BC0131C224CB239B9F39139B1324A204B8FC4024B8C94219AB4480DB0901DB11230ABA027FB0198000800AB9728C9813B2CC44B011000E258998329A882A91ED0A10140A0123EA8D32AB9C5211CA1A3308D8209C4119911333FC18199B8430190A08390798F98609A820094B22A92C4B3220897D0308009591BA428229589E8B3A291F3121A92218789205089299E10492EC028B1000281E300BAE0023D9029281BC2410E90B880CB3108258931A29BAF03AB34E079880A9B28D23011A28D410983C9102CD14A88978A211B2808C25AAAC2815BC1A091A39D07A801093E01BB969808A2729980299AE992219C23882A302CC408FB002A20203E210142A998CF9481054B200992F202CA400A1101050011909CD3101F005B00A9C31199201BB300B610C11830E4238B940A3A0AE12C0AB549A061010700C096300BF09200AA037A09A2301BC2A398F9A3313E10B831C2D219128BA6A0227A8A920BD280022B3CBCA3F89249AB82004DA01CB52CA8011B1092CDA4083BAA42993EA691FF9CC989001630104290ABD91A09833207408888AAB9A04BA37403209B91B909CC32792183C083AB2CA91AC56319842A8A18AB894801273B2BE18288B941692321118500150BA0212451935352991431A3839FD8899CC0A23A1BB680B9989CBAC4390F280AD1922CBD9199B80129BDF08D70AC0AA682223A9304080AD0198AB8603DA180909B911E0019334EC1931089918A875919081190392F9802985020E8131C082DA0B29510208AA46B8D821AC1234B2AD0849890730116008940C0131BB46A1DA09239A0B40228390FB110380D110D9196A0831AABB34B2B8FB420B0962A09A32BC2008FB282A86A0CA8C428893B398AB1F3853E99A038BAA63AC09481A2A23B4E9B012D918448B8A324A9B4211BB3701DB4300BC19429B3116B0A413BF0A319A9950829E4221BA1328DF3112AA0221EA490480AA101098B12B8D6112A99142E90001901F33899D1322D08493BB8941031A00ADD9608089139D44A8A80101C9003C02BC005C111B242F4082B89E050091A9189B6A128AB482AF1321BA9E3203BA1421CA530880D919019214E083AD5933A9AA6491AB250AA842C128B9739A00128AB873ADA039A22C072AB851A0899038C917AA87C0111009BA5193AE8B5100BA3A10001094BF1411DC0032CB083A001C1718BA34A1BC930C1223E9292190C419EA2A1049B85282A3889E43A2DA091A1261B9904890AA91DE08148E22199C3409BC29130CA522A5AABB5188BA43CC996203B291CD2110940A0A2A4111BF3132C92129910403C019C5A1B4D2BB430C095A8B34A0A862B81B3808F932A0FB31309A01A2CA3282FB361C9148BA1285C1AA9593DA980B0838CA30511D2B7188B80398963B0232D1B0D9900599391B4B1C4990AB12E41A8422A99C3A9DC213A3400F3A4290A8BA858A1026BC520AAB1A907912990803813BF107809B0022A0CC4847B9918C8943AA1837B3AC0D21088C211490B95111C550116001BC21100A34AA9C4B2223EF98308B308A2A3EA042CB1036A2C90809A80117AB0A5B218A0D2B14839D201B9A738C0A36CB0845BB9A4382BB2384D9A912B1AA2959A3C85923D99230BD3005CE291000802911F888198D408B19481180A282F9990420BAB17003AABC25938C890682EC1132BD1112BE1122A1A212CA3A26A0A91BAD7018A979181A0B328399B284F1A0128B9488EC201A091C481A291F9826C9A82202A89A3210EF2022899835B2AA908380CE5838995201B9BC3393D9986100B9080C92D29A033B9071C98632DA0489A282C11A198D292B003EA844AC41809D3212BC16A3B302888A8B9935EABA72089B10AF19180A422985A9A100AC51B011200A9A411A231AA712DBAA7210DB3221EB1043AA818A9B612A830D0A220B2083BD613AAB48230C2E0922001BB602BF1581B881CC8823BA8A2125F1A9180A0B230C127592C1C98932CA1A48120A9242CA9E2301FB24198A53C8B81B8314DA9A628A8A53909292C9A133FA8A5001B80798A021AB279AB852AA984392A88E61189C51029A8133D99015E99A288B42889C3221D91281C19A29323C1709A300F90202C000839F0C1821A084089047AC89200F2013AD082119A393A3F9B95B1C2820A2AC1130C051CBA869039933B6F88A821299AB693181BC1182A8930815A8CD2B194A07B094C1A91802A91C21CB6A1A2233B1F101B2AF2121AB46B1BC1194C050118001800290921EB002BF283B0C49390C35BA992492B033D88013AC09AC9444CB092971900819D122AB1308D8192E4380A98031C7B089928C995A108B0A32A0D6A829B13239FC21029A98407CB2191C992823279800CAB8709999AD9A3490107A9835A1E12020359910389F098908118A0129AF29BCAD830B05039C08B2A9C0C2C048995820A83B3A0CB7AA1915193882F80089A72001C3100E20A98814A1E01B12133AE0904313C1C002A0903E08B0F821BB206A898C3050B213D2C000AC9118E289BCFA912B2B72080A53040302369201480A0001DA9180C91D3108D9BABC99829B4800128FD2B19AB00800732A950B99A5AA85B28972209919893AB2C0E0106001CA73198439DBA228A5828AA08E2EF8B0A1191B32719022B4A6411864080881990898A18201873F0C890B1AA0890391091FBBAF8928948390C20A2F881921048183D20210DA492081C204A2A990791A88A3D215B59091A95C021288C0000F983201B1C5B19A8CA121903213D281F29BA9E42B1D14010CA91040AB04182AA5C408C1A13C0C211F280DBCD9A2A033269A3393D21813663001310AB990A0F00092890A0CCF9AA98083A11815101C6B13801000B279189918F0B83AA4AA299BBD6B089A8A26999E0421EB042189B849268019548A0A23A9896288CA1995BC8A01AF9A25A88134A0021A088070901A44DC9930B992B01898CD52A3CE38818ED000F003E098419BB330EC430910280856CA08319099096499A818C902CCA945998A25B9A00408A0A960B91338E00A3006B8AC24D89209E9419A4819920699121928889F1A01A203FC9955BA0802A988103638A28C2A802994B4B9BA271C2E51098D100482B91834BB884099B23290E1C819621ACA07AA9A211440AE8209DB21240901259D810AA915A9095301DC1933ACBA53C1AB3323CD1832D9928990400071DB001A9009A5209A521B2A18D8AC4222992611BD8182A884B08310F80910F820129A0155C98A41A9892988083700A9829E08BB93C3BA6310BA0483E990231D10249B08BA1AE812C09B89C50C89903E000124A28898108904CA62032503A411D01070009389AC06A885822C00820D8AB16B0B29B11D14A10F21B12A4F20100020AB4291AE61189A2A133BB040EA70818090249F90101A0820A80151F088A3900B00B33178993A1289AC985D093208B62BBC0B0CB4508A98192D81C100A0D8332E004401ADA91B2D20300910A1E0019D0023AA31CB812849A0609A070014999C881010C5090034B91792919AAF12090E0329221D9821EB0980990601AB6914A3CBAD35A390889B7A24D3A9881292C8D01B2043CC9B5023A2ABA96302CA0C3203E1EC1B4223D1BCAE4C02E09100193313B0AA22273681112912C9C888898284911B3918FAFD2100982302AC1092D9BE1392A836B009B9189E830185088D2202DC7001500102BAA640AB7310CB20899926B1AA4213BD1042E898101A28119491FC8902900113A9C529FA111294D898011081AB44AC99628B01182193F8AD33399E36C99820098A0390B21E260899498812AA44ADA328BD3012D08932A2B8BA408223FF118A8031AB4202BB7290DC3232DC2A3188A097A08D221AAD1211C00799A113AD393A0018C954D18809220C8C91198A5311B9AFAC510A0943AB0A6389BC34108801A1A082E18C3489AF210998814011AA449AC012DB3312C9A8139BDD1041FD0141BA1813BB1228A0005B00D05099B87299BA44A28A9013ACE144B9830E0923CB4512AE31980832CB138B9132CF111C1A49810C8310BB5809A1B022FA2B4CB0012000C0808C3B62109A0307B99C80728A8818BE32309C84119B5490C011AA0838D278AB12BA93211A4DA381FB1340BD821998CC3801C062989B8822A002040FBD2290188612AE12999025C910A92105BB9310E82129879AA3AC1212FA2202FA882291C241B218ABA023E4038D859CB210C94609B01A889833A7BA182D1188284BB163FD8210901B8944E988189109519B1310DA36C9881190AA9238F9033AFA43A0A402B89940A302C1F01429B111AF359B9932098A17989C3999319B46B99963BD0841A898139AA9328728E811909B2815888940A08B130581F914A8848D98219107BA0200FB37A99013BB2590DA2311CA1017B9A93298AA5408C833BE91C011F00AA1091281AA559CB960801190A10B59129490D3B98B5320F925BB1209B844D99B4228CC4213BAA944B98A5489AC18102916B9A8249D902293CF1122DA0836B8AB4698BA3590BB2201CB2123B9B9719F1128A024BB8A6389C945A99019801B0210BA35B98C5843AAC053BCA96800991A459A8A21A29B1429B831BA09D8270C9971889913C01901B916B0899150AF4211D90121C8903803E98498BA34A0091017B1C08080009A2482A1CB885088D03790CA2A110E2110A18A348F3118B12D9838AC8042CC0952AC0219A0A02108C140C810040B8A249F390219A58B00C03BB35901A9A370A130F822AA40C93C99518C950A018A0109829B45C98338A2BD8000600AC17A8190B189B0BC2A3AFB2E0119108A48C7909438A823C2189A49A15EA201820BB932B32C8C200410B2A313344B9290F13C03AB26C82E11912030A8119C2729BB2708AA0916389BBA0A01A2499E83872920ACC180A8885899330A111FC001FE90911328201588810100B0B580423B2B09D6BA2B36A950220BB1099FAA9BBA124359DB31BAA90B02E7AB23B089E04BB8A5C9328C212BBF10B13A192B9730A951BAB0007191D4190B240A1D998B238168129DB00C222201E041080199C791A81BB934D90B31D949022270B3823AC439AA1A8AEA500B4950A8089B890839E986A02F8389BFA1818091003116B9B20F49910902904B8C49139118EA01496000C001802C199C2A161583C2AC32A13AF69198A21990928C6E2A292B810589849298B80E1C112192C20B97A590A9891A03218AE04C322498998C3D581019290835C3C1A7AA981B4A3181281AB170A4B389902F1B41409108B1A8B432BAA0DF312B99938181E23DD091859A8E0921908993B8FC20420E0108111E3202900093D932919FA038094905A1C93912923E2D013917091BB885AD22BE30A0220AA18952C991AD802499AA1B68884092DC13AE018C238CB6A0020091831BE03B3072C23AD012909AA86984900A49129D4399039141B90F930A8229A43F20B102ABB7AE91891B2802E91B002280ABB17B07B019AAB96193D00A2CB213220B986193D49DC000B0020C20CD1B84410938B220D14D11B0111CB69B01308E8A8289BAAA98277A189A0083B1A968108ABC3020908AF2D910A2790A8D19B9C62B1913800B807B910B24E011110C1E1190228FB10B14211911A981AA126BB58041B40B219048A8235A69B1161B908190D87210C21A9A1BB31DC26A93010B128FBBBA16991B93D31103C106A08E1904A912095AB0A82173A83DB9922BD33819B6B9B207AB09401B0C39D30843209C93A1981430CBD1399CDB2B4831E0A88009B07118B0882AF8F812191052A1C9389A1F84031938D1899928B82B6A96AA00352B0A8A90231731913C928DD0931885226B9A9CA008006A81A10451ABAB83D9A8F981082138AD130B000030037ABD00098F818219030BA870B0998FF0E08080808080808080808080808888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888";

    private StringBuffer stb = new StringBuffer();
    private String buffer;
    private boolean isCount = false;
    private int count = 0;
    private int offset = 5;
    //App 이 갖는 GATT 이벤트에 대한 콜백 메서드를 구현합니다.
    private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
        final Handler handler = new Handler(Looper.getMainLooper());

        @Override
        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {//연결 상태가 바뀌면 호출됨
            String intentAction;
            if (newState == BluetoothProfile.STATE_CONNECTED) {
                intentAction = ACTION_GATT_CONNECTED;
                mConnectionState = STATE_CONNECTED;
                broadcastUpdate(intentAction);
                Log.i(TAG, "Connected to GATT server.");
                // Attempts to discover services after successful connection.
                Log.i(TAG, "Attempting to start service discovery:" + mBluetoothGatt.discoverServices());

            } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {
                intentAction = ACTION_GATT_DISCONNECTED;
                mConnectionState = STATE_DISCONNECTED;
                Log.i(TAG, "Disconnected from GATT server.");
                broadcastUpdate(intentAction);
            }
        }

        /**
         * allback invoked when the list of remote services, characteristics and descriptors
         * setCharacteristicNotification:: Read/Write/Notification 권한 설정
         */
        @Override
        public void onServicesDiscovered(BluetoothGatt gatt, int status) { //BLE 장치에서 GATT 서비스들이 발견되면 호출된다.
            if (status == BluetoothGatt.GATT_SUCCESS) { //gatt 서비스들을 이용가능한지 확인 할 수 있다.
                broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED);

                BluetoothGattService openService = gatt.getService(UUID_SERVICE);
                BluetoothGattCharacteristic openTxChar = openService.getCharacteristic(UUID.fromString("ab5e0004-5a21-4f05-bc7d-af01f617b664")); // 데이터 수신 UUID
                boolean notiResult = gatt.setCharacteristicNotification(openTxChar, true); // Notification 활성화 및 데이터 receive ::
                //boolean readResult = mBluetoothGatt.readCharacteristic(openTxChar);
                // Log.d("GATTService", "Characteristic Read : " + readResult);
                Log.d("GATTService", "Characteristic Noti : " + notiResult);

                BluetoothGattDescriptor descriptor = openTxChar.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG); //데이터 수신 UUID 에 특성을 설명하는 메타데이타
                descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE); // write했다가 read 할 떄 데이터를 읽기 위한 작업 그래서 descriptor가 필요
                boolean success = mBluetoothGatt.writeDescriptor(descriptor); //변경된 UUID descriptor // 설명된 데이타를 Gatt서버에 write한다.
                Log.d("GATTService", "writeDescriptor:" + success);

            } else {
                Log.w(TAG, "onServicesDiscovered received: " + status);
            }
        }

        @Override
        public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) { ////characteristic를 읽는데 성공하면 호출
            if (status == BluetoothGatt.GATT_SUCCESS) {
                broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);
            }
        }

        /**
         * BLE 장치간 데이터 전송 (사전에 Notification으로 권한 설정을 해주어야한다.)
         * @param gatt
         * @param characteristic
         */
        @Override
        public void onCharacteristicChanged(BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {//특성의 값이 바뀔 때
            Log.d("GATTService / ", "onCharacteristicChanged::" + characteristic.getValue());
            final Intent intent = new Intent(ACTION_DATA_AVAILABLE);

            handler.post(new Runnable() {
                @RequiresApi(api = Build.VERSION_CODES.N)
                @Override
                public void run() {

                    if (characteristic.getUuid().equals(UUID_CTL)) {
                        Log.d("GATTService ", "Characteristic Noti UUID : " + characteristic.getUuid());
                        Log.d("GATTService ", "Characteristic Noti Value (Byte) : " + Util.byteArrayToHex(characteristic.getValue()));
                        Log.d("GATTService ", "Characteristic Noti Value (String) : " + new String(characteristic.getValue(), StandardCharsets.UTF_8));
                        byte[] searchData = characteristic.getValue();
                        String firstData = String.valueOf(searchData[0]);

                        if (firstData.equals("8")) { //Master >> searchData
                            Log.d("GATTService ", "getSearchData");

                            BluetoothGattService openService = gatt.getService(UUID_SERVICE);
                            BluetoothGattCharacteristic openMic = openService.getCharacteristic(UUID_TX);

                            byte data[] = Util.hexStringToByteArray("0C00000000000000000000000000000000000000"); // open Mic
                           // byte data[] = Util.hexStringToByteArray("0A00010000000000000000000000000000000000"); // 초기화
                            Log.d("GATTService ", "Mic_open : " + Util.byteArrayToHex(data));
                            Log.d(TAG, "GATTService " + writeCharacteristic(openMic, data));

                        } else if (firstData.equals("4")) {
                            Log.d("GATTService ", "Audio_start");

                            BluetoothGattService openService = gatt.getService(UUID_SERVICE);
                            BluetoothGattCharacteristic openTxChar = openService.getCharacteristic(UUID_RX); // 데이터 수신 UUID
                            boolean notiResult = gatt.setCharacteristicNotification(openTxChar, true); // Notification 활성화 및 데이터 receive ::
                            //boolean readResult = mBluetoothGatt.readCharacteristic(openTxChar);
                            // Log.d("GATTService", "Characteristic Read : " + readResult);
                            Log.d("GATTService", "Characteristic Noti : " + notiResult);

                            BluetoothGattDescriptor descriptor = openTxChar.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG); //데이터 수신 UUID 에 특성을 설명하는 메타데이타
                            descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE); // write했다가 read 할 떄 데이터를 읽기 위한 작업 그래서 descriptor가 필요
                            boolean success = mBluetoothGatt.writeDescriptor(descriptor); //변경된 UUID descriptor // 설명된 데이타를 Gatt서버에 write한다.
                            Log.d("GATTService", "writeDescriptor:" + success);

                        } else if (firstData.equals("C")) {
                            Log.d("TAG", "GATTService: Mic_open_error ");
                        } else if (firstData.equals("0")) {
                            Log.d("TAG", "GATTService: Mic_close");
                        } else if (firstData.equals("A")) {
                            Log.d("TAG", "audio_sync");
                        }

                    } else if (characteristic.getUuid().equals(UUID_RX)) {
                        Log.d("GATTService ", "Audio_data");
                        Log.d("GATTService ", "Characteristic Noti UUID : " + characteristic.getUuid());
                        //  Log.d("GATTService ", "Characteristic Noti Value (Byte) : " + Util.byteArrayToHex(characteristic.getValue()));

                        byte[] getData = Util.getByte(characteristic.getValue());
                        Log.d("GATTService ", "Characteristic getData : " + Util.byteArrayToHex(getData));
                        if (count == 0) {
                            count = -1;
                            Handler handler = new Handler();
                            handler.postDelayed(new Runnable() {
                                @Override
                                public void run() {
                                    isCount = true;
                                }
                            }, 2500);

                        }


                        //Log.d("GATTService ", "Characteristic getData = Util (Byte) : " + Util.byteArrayToHex(getData));

                        // Util.byteArrayToHex(ADPCMDecoder.decodeBlock(getData,1));
                    }

                /*    if(firstData.equals("8")){
                        Log.d("GATTService /", "success!" );
                    }*/



                    /*//openMic
                    BluetoothGattService openService        = gatt.getService(UUID_SERVICE);
                    BluetoothGattCharacteristic openMic  = openService.getCharacteristic(UUID.fromString("ab5e0002-5a21-4f05-bc7d-af01f617b664")); // 데이터 수신 UUID

                    byte data[] = Util.hexStringToByteArray("0C00000000000000000000000000000000000000");
                    Log.d(TAG, "GATT_SERVICES = " + writeCharacteristic(openMic, data));*/
                }

            });
            if (isCount) {
                isCount = false;
                    /*BluetoothGattService openService = gatt.getService(UUID_SERVICE);
                    BluetoothGattCharacteristic openTxChar = openService.getCharacteristic(UUID_CTL); // 데이터 수신 UUID
                    boolean notiResult = gatt.setCharacteristicNotification(openTxChar, true); // Notification 활성화 및 데이터 receive ::
                    //boolean readResult = mBluetoothGatt.readCharacteristic(openTxChar);
                    // Log.d("GATTService", "Characteristic Read : " + readResult);
                    Log.d("GATTService", "Characteristic Noti : " + notiResult);

                    BluetoothGattDescriptor descriptor = openTxChar.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG); //데이터 수신 UUID 에 특성을 설명하는 메타데이타
                    descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE); // write했다가 read 할 떄 데이터를 읽기 위한 작업 그래서 descriptor가 필요
                    boolean success = mBluetoothGatt.writeDescriptor(descriptor); //변경된 UUID descriptor // 설명된 데이타를 Gatt서버에 write한다.*/

                BluetoothGattService openServiceTX = gatt.getService(UUID_SERVICE);
                BluetoothGattCharacteristic closeMic = openServiceTX.getCharacteristic(UUID_TX);

                byte data[] = Util.hexStringToByteArray("0D00000000000000000000000000000000000000"); // close Mic
                Log.d("GATTService ", "MicClose : " + Util.byteArrayToHex(data));


                if (writeCharacteristic(closeMic, data)) {

                    Log.d(TAG, "GATTService writeCharacteristic mic close true");
                    Log.d(TAG, "GATTService getAllDataSize :" + Util.getAllData().size());
                    ArrayList<Byte> temp = Util.getAllData();
                    byte[] changeData = Util.hexStringToByteArray(sampleDATA);

                    PcmToWav pw = new PcmToWav();
                    //Log.d("GATTService ", "arrToByte : " + Util.arrToByte(temp).length);

                    //pcm file 생성하기
                    mFilePath = "/data/data/com.remote.remotecontrol/cache/record.wav";

                    byte []getData = Util.arrToByte(temp);
                    StringBuffer sb = new StringBuffer();
                    for (final byte b : getData) {
                        sb.append(String.format("%02x", b & 0xff));
                    }
                    Convert io = new Convert();
                    io.setData(sb.toString());

                    Retrofit retrofit = new Retrofit.Builder().baseUrl(URL).addConverterFactory(GsonConverterFactory.create()).build();

                    RetrofitInterface mRetrofitInterface = retrofit.create(RetrofitInterface.class);
                    mRetrofitInterface.getConverter("application/json",io).enqueue(new Callback<SpeechModel>() {
                        @Override
                        public void onResponse(Call<SpeechModel> call, Response<SpeechModel> response) {
                            Log.d(TAG ,"##REST## Success network");
                            Log.d(TAG ,"##REST## code1:"+response.code());
                            Log.d(TAG ,"##REST## code2:"+response.code());
                            Log.d(TAG ,"##REST## getCode:"+response.body().getStatus().getCode());
                            Log.d(TAG ,"##REST## getMessage:"+response.body().getStatus().getMessage());

                            if(response.body().getStatus().getCode().equals("200")){
                                Log.d(TAG ,"##REST## code:200!!");
                               //String wavFileData = response.body().getData();

                                Log.d(TAG ,"##REST## getData : "+response.body().getData());
                                if(response.body().getStatus().getCode().equals("200")){
                                    BluetoothGattService openService = gatt.getService(UUID_SERVICE);
                                    BluetoothGattCharacteristic Quick = openService.getCharacteristic(UUID_TX);

                                    /*SendCommand sendCommand = new SendCommand();
                                    byte [] getCommandData = sendCommand.SendCommand();

                                    for(int seq= 0 ; seq <4;seq++){
                                        switch (seq){
                                            case  0:
                                                byte[] sendData1 = sendCommand.IrSend(getCommandData,(byte)0x00);
                                                Log.d("GATTService ", "Quick1 : " + Util.byteArrayToHex(sendData1));
                                                writeCharacteristic(Quick, sendData1);
                                                break;
                                            case 1 :
                                                byte[] sendData2 = sendCommand.IrSend(getCommandData,(byte)0x01);
                                                Log.d("GATTService ", "Quick2 : " + Util.byteArrayToHex(sendData2));
                                                writeCharacteristic(Quick, sendData2);
                                                break;
                                            case 2 :
                                                byte[] sendData3 = sendCommand.IrSend(getCommandData,(byte)0x02);
                                                Log.d("GATTService ", "Quick3 : " + Util.byteArrayToHex(sendData3));
                                                writeCharacteristic(Quick, sendData3);
                                                break;
                                            case 3 :
                                                byte[] sendData4 = sendCommand.IrSend(getCommandData,(byte)0x03);
                                                if(sendData4 == null){
                                                    Log.d("GATTService ", "Quick4 : length<54 ");
                                                }else{
                                                    Log.d("GATTService ", "Quick4 : " + Util.byteArrayToHex(sendData4));
                                                    writeCharacteristic(Quick, sendData4);
                                                }
                                                break;

                                        }
                                    }*/
                                }

                               /*byte[] converterByte = Util.hexStringToByteArray(wavFileData);

                                FileOutputStream fos = null;
                                try {
                                    fos = new FileOutputStream(mFilePath);
                                    fos.write(converterByte, 0, temp.size());
                                } catch (FileNotFoundException e) {
                                    e.printStackTrace();
                                } catch (IOException e) {
                                    e.printStackTrace();
                                }*/


                                // pcm file to war file
                                File read = new File("/data/data/com.remote.remotecontrol/cache/record.pcm");
                                File out = new File("/data/data/com.remote.remotecontrol/cache/mic.wav");

                                //try {
                                // pw.PCMToWAV(read, out, 1, 160000, 16);
                                /*Thread thread = new Thread(new Runnable() {
                                    @Override
                                    public void run() {
                                        try {
                                            String imgFile = "/data/data/com.remote.remotecontrol/cache/record.wav";
                                            File voiceFile = new File(imgFile);

                                            String language = "Kor";        // 언어 코드 ( Kor, Jpn, Eng, Chn )
                                            String apiURL = "https://naveropenapi.apigw.ntruss.com/recog/v1/stt?lang=" + language;
                                            URL url = new URL(apiURL);

                                            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                                            conn.setUseCaches(false);
                                            conn.setDoOutput(true);
                                            conn.setDoInput(true);
                                            conn.setRequestProperty("Content-Type", "application/octet-stream");
                                            conn.setRequestProperty("X-NCP-APIGW-API-KEY-ID", clientId);
                                            conn.setRequestProperty("X-NCP-APIGW-API-KEY", clientSecret);
                                            // TV_stt_log.append("STT: 서버 설정완료\n");
                                            OutputStream outputStream = conn.getOutputStream();
                                            FileInputStream inputStream = new FileInputStream(voiceFile);
                                            byte[] buffer = new byte[4096];
                                            int bytesRead = -1;
                                            while ((bytesRead = inputStream.read(buffer)) != -1) {
                                                outputStream.write(buffer, 0, bytesRead);
                                            }
                                            outputStream.flush();
                                            inputStream.close();
                                            BufferedReader br = null;
                                            int responseCode = conn.getResponseCode();
                                            if (responseCode == 200) { // 정상 호출
                                                br = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                                                //TV_stt_log.append("STT: 서버로부터 정상적으로 호출\n");
                                            } else {  // 오류 발생
                                                System.out.println("error!!!!!!! responseCode= " + responseCode);
                                                br = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                                            }
                                            String inputLine;

                                            if (br != null) {
                                                StringBuffer response = new StringBuffer();
                                                while ((inputLine = br.readLine()) != null) {
                                                    response.append(inputLine);
                                                }
                                                br.close();
                                                System.out.println(response.toString());
                                                json = response.toString();
                                                JSONObject jsonObject = new JSONObject(json);
                                                String result = jsonObject.getString("text");
                                                Log.d("TAG", "result : " + result);
                                                // TV_ble_log.append("STT: 수신된 데이터>>"+result+"\nSTT: 종료"+"\n");


                                            } else {
                                                System.out.println("error !!!");
                                            }
                                        } catch (Exception e) {
                                            System.out.println(e);
                                        }
                                    }
                                });*/

                                //thread.start();
                                // } catch (FileNotFoundException e) {
                                // TODO Auto-generated catch block
                                //     e.printStackTrace();
                                // } catch (IOException e) {
                                // TODO Auto-generated catch block
                                //    e.printStackTrace();
                                // }



                            }

                        }

                        @Override
                        public void onFailure(Call<SpeechModel> call, Throwable t) {
                            Log.d(TAG ,"##REST## converter False network"+t.toString());
                        }
                    });

                    /*Retrofit retrofit = new Retrofit.Builder().baseUrl(URL).addConverterFactory(GsonConverterFactory.create()).build();

                    RetrofitInterface mRetrofitInterface = retrofit.create(RetrofitInterface.class);
                    mRetrofitInterface.getConverter("application/json",io).enqueue(new Callback<SpeechModel>() {
                        @Override
                        public void onResponse(Call<SpeechModel> call, Response<SpeechModel> response) {
                            Log.d(TAG ,"##REST## Success network");
                            Log.d(TAG ,"##REST## code1:"+response.code());
                            Log.d(TAG ,"##REST## code2:"+response.code());
                            Log.d(TAG ,"##REST## getCode:"+response.body().getStatus().getCode());
                            Log.d(TAG ,"##REST## getMessage:"+response.body().getStatus().getMessage());
                        *//*if(response.body().getStatus().getCode().equals("200")){
                            Log.d(TAG ,"##REST## code:200!!");

                        }*//*

                        }

                        @Override
                        public void onFailure(Call<SpeechModel> call, Throwable t) {
                            Log.d(TAG ,"##REST## converter False network"+t.toString());
                        }
                    });*/


                    intent.putExtra(EXTRA_DATA, "onCharacteristicChanged Data OK...");
                    sendBroadcast(intent);

                    Log.d(TAG,"sb.length:"+sb.length());






                } else {
                    Log.d(TAG, "GATTService writeCharacteristic mic close fales");
                }
            }

        }


    };

    private String json = null;
    private String mFilePath = null;
    private final String clientId = "629fhvdo3y";                                    // Application Client ID"
    private final String clientSecret = "4h6uYJg24jBte1fEqvv13SGs9WVYmrFBb9yHFmTq";     // Application Client Secret"


    private void broadcastUpdate(final String action) { // 인자가 하나인 action DeviceControlActivity로 Message 날린다.
        final Intent intent = new Intent(action);
        sendBroadcast(intent);
    }

    private void broadcastUpdate(final String action, final BluetoothGattCharacteristic characteristic) { //BLE 장치로부터 받아오 데이터를 DeviceControlActivity로 넘겨주기 위해 이 함수를 사용한다.
        final Intent intent = new Intent(action);

       /* // 심박수 측정 프로필에 대한 특수 처리입니다. 데이터 파싱은
        // 프로필 사양에 따라 수행 :
        // http://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.heart_rate_measurement.xml
        if (UUID_HEART_RATE_MEASUREMENT.equals(characteristic.getUuid())) { // GATT를 사용하는 장치와 연결되었을 때 심박수를 받아오도록 설정되어 있다.
            int flag = characteristic.getProperties();
            int format = -1;

            if ((flag & 0x01) != 0) { //16진수인지 8진수인지 확인
                format = BluetoothGattCharacteristic.FORMAT_UINT16;
                Log.d(TAG, "Heart rate format UINT16.");
            } else {
                format = BluetoothGattCharacteristic.FORMAT_UINT8;
                Log.d(TAG, "Heart rate format UINT8.");
            }

            final int heartRate = characteristic.getIntValue(format,1 );// 수집된 심박동데이터 로직

            Log.d(TAG, String.format("Received heart rate: %d", heartRate));
            intent.putExtra(EXTRA_DATA, String.valueOf(heartRate)); //intent를 통해 심박동 데이터를 보내준다.

        } else {
            //다른 모든 프로필의 경우 HEX 형식의 데이터를 씁니다.
            final byte[] data = characteristic.getValue();
            if (data != null && data.length > 0) {
                final StringBuilder stringBuilder = new StringBuilder(data.length);
                for(byte byteChar : data)
                    stringBuilder.append(String.format("%02X ", byteChar));
                intent.putExtra(EXTRA_DATA, new String(data) + "\n" + stringBuilder.toString());
            }
        }
        sendBroadcast(intent);*/
    }

    public class LocalBinder extends Binder {
        public BluetoothLeService getService() {
            return BluetoothLeService.this;
        }
    }

    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    } //DeviceControlActivity에서 BindService로 서비스를 연결하면 onBind 함수가 호출

    @Override
    public boolean onUnbind(Intent intent) {
        // After using a given device, you should make sure that BluetoothGatt.close() is called
        // such that resources are cleaned up properly.  In this particular example, close() is
        // invoked when the UI is disconnected from the Service.
        close();
        return super.onUnbind(intent);
    }

    private final IBinder mBinder = new LocalBinder();

    /**
     * Initializes a reference to the local Bluetooth adapter.
     *
     * @return Return true if the initialization is successful.
     */
    public boolean initialize() {
        // For API level 18 and above, get a reference to BluetoothAdapter through
        // BluetoothManager.
        if (mBluetoothManager == null) {
            mBluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
            if (mBluetoothManager == null) {
                Log.e(TAG, "Unable to initialize BluetoothManager.");
                return false;
            }
        }
        mBluetoothAdapter = mBluetoothManager.getAdapter();
        if (mBluetoothAdapter == null) {
            Log.e(TAG, "Unable to obtain a BluetoothAdapter.");
            return false;
        }

        return true;
    }

    /**
     * Connects to the GATT server hosted on the Bluetooth LE device.
     *
     * @param address The device address of the destination device.
     * @return Return true if the connection is initiated successfully. The connection result
     * is reported asynchronously through the
     * {@code BluetoothGattCallback#onConnectionStateChange(android.bluetooth.BluetoothGatt, int, int)}
     * callback.
     */
    public boolean connect(final String address) {
        if (mBluetoothAdapter == null || address == null) { //null 검사
            Log.w(TAG, "BluetoothAdapter not initialized or unspecified address.");
            return false;
        }

        // Previously connected device.  Try to reconnect.
        if (mBluetoothDeviceAddress != null && address.equals(mBluetoothDeviceAddress)
                && mBluetoothGatt != null) {
            Log.d(TAG, "Trying to use an existing mBluetoothGatt for connection."); //연결을 위해 기존 Gatt사용 시도
            if (mBluetoothGatt.connect()) {
                mConnectionState = STATE_CONNECTING;
                return true;
            } else {
                return false;
            }
        }

        final BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address);
        if (device == null) {
            Log.w(TAG, "Device not found.  Unable to connect.");
            return false;
        }
        // We want to directly connect to the device, so we are setting the autoConnect
        // parameter to false.
        mBluetoothGatt = device.connectGatt(this, false, mGattCallback); //디바이스와 연결 시도
        Log.d(TAG, "Trying to create a new connection.");
        mBluetoothDeviceAddress = address;
        mConnectionState = STATE_CONNECTING;

        return true;
    }

    /**
     * Disconnects an existing connection or cancel a pending connection. The disconnection result
     * is reported asynchronously through the
     * {@code BluetoothGattCallback#onConnectionStateChange(android.bluetooth.BluetoothGatt, int, int)}
     * callback.
     */
    public void disconnect() {
        if (mBluetoothAdapter == null || mBluetoothGatt == null) {
            Log.w(TAG, "BluetoothAdapter not initialized");
            return;
        }
        mBluetoothGatt.disconnect();
    }

    /**
     * After using a given BLE device, the app must call this method to ensure resources are
     * released properly.
     */
    public void close() {
        if (mBluetoothGatt == null) {
            return;
        }
        mBluetoothGatt.close();
        mBluetoothGatt = null;
    }

    /**
     * Request a read on a given {@code BluetoothGattCharacteristic}. The read result is reported
     * asynchronously through the {@code BluetoothGattCallback#onCharacteristicRead(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
     * callback.
     *
     * @param characteristic The characteristic to read from.
     */
    public void readCharacteristic(BluetoothGattCharacteristic characteristic) { //연결된BLE 장치의 특성을 읽어오라는 명령을 내린다.
        Log.d(TAG, "Call readCharacteristic");
        if (mBluetoothAdapter == null || mBluetoothGatt == null) {
            Log.w(TAG, "BluetoothAdapter not initialized");
            return;
        }
        mBluetoothGatt.readCharacteristic(characteristic);
    }

    /**
     * 제공 특성에 대한 알림을 활성화하거나 비활성화
     *
     * @param characteristic Characteristic to act on.
     * @param enabled        If true, enable notification.  False otherwise.
     */
    public void setCharacteristicNotification(BluetoothGattCharacteristic characteristic, //BLE 장치가 데이터를 보낼 때를 기다려, 보내면 받아오도록 리스너를 설정한다.
                                              boolean enabled) {


        if (mBluetoothAdapter == null || mBluetoothGatt == null) {
            Log.w(TAG, "BluetoothAdapter not initialized");
            return;
        }
        mBluetoothGatt.setCharacteristicNotification(characteristic, enabled);/*ENABLE_NOTIFICATION_VALUE*/
        //if (UUID_URINE_ANALYZER.equals(characteristic.getUuid())) {

        BluetoothGattDescriptor descriptor = characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG); //데이터 수신 UUID 에 특성을 설명하는 메타데이타
        descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE); // write했다가 read 할 떄 데이터를 읽기 위한 작업 그래서 descriptor가 필요
        mBluetoothGatt.writeDescriptor(descriptor); //변경된 UUID descriptor // 설명된 데이타를 Gatt서버에 write한다.

        Log.d(TAG, "Service Notification Execution");
        //}

    }

    /**
     * Retrieves a list of supported GATT services on the connected device. This should be
     * invoked only after {@code BluetoothGatt#discoverServices()} completes successfully.
     *
     * @return A {@code List} of supported services.
     */
    public List<BluetoothGattService> getSupportedGattServices() { //BLE 장치에서 제공되는 서비스들을 받아올수 있도록 해준다.
        if (mBluetoothGatt == null) return null;

        return mBluetoothGatt.getServices();
    }

    /**
     * 연결된 디바이스에 데이터 쓰기
     *
     * @param characteristic
     * @param data
     * @return
     */
    public boolean writeCharacteristic(BluetoothGattCharacteristic characteristic, byte[] data) {
        if (mBluetoothAdapter == null || mBluetoothGatt == null) {
            Log.w(TAG, "BluetoohtAdapter not initialized");
            return false;
        }
        characteristic.setValue(data);
        return mBluetoothGatt.writeCharacteristic(characteristic);
    }

}
